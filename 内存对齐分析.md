#### 内存对齐
理论上，int占4 byte，char占一个1 byte，那么将它们放到一个结构体中应该占4+1=5byte，但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的
```c
struct Struct {
    int a;  // 4
    char b; // 1
}struct4;

NSLog(@"%lu",sizeof(struct4)); // 输出为 8
```

计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐
#### 为什么要内存对齐
- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
  - 一个变量的内存地址刚好位于它本身长度的整数倍，他就被称做自然对齐
  - 内存是否对齐，会影响到数据的读取效率
#### 内存对齐原则
- 数据成员对⻬规则:结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方(即首地址的位置），以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始（比如int为4字节,则要从4的整数倍地址开始存储）
- 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b，b里有char、int 、double等元素，那b应该从8的整数倍开始存储.)
- 结构体的总大小,也就是sizeof的结果,必须是其内部最大成员的整数倍，不足的要补⻬
