### DOM事件流
DOM2级事件，规定的事件流包含3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段
首先发生的事件捕获为截获事件提供机会，然后是实际的目标接收事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应

### addEventListener
#### 参数
- 要处理的事件方式
- 事件处理的函数，可以为匿名函数，也可以为命名函数（但如果需要删除事件，必须是命名函数）
- 一个布尔值，代表是处于事件冒泡阶段处理还是事件捕获阶段（true：表示在捕获阶段调用事件处理程序；false:表示在冒泡阶段调用事件处理程序），默认值为false
- 第三个参数也可传入对象
```
{
    capture: false, // 捕获
    passive: false, // 优化浏览器滚动
    once: false     // 只触发一次
}
```

### 特点
多次添加的事件处理函数，是按先进后出的执行顺序

### 事件委托
利用触发冒泡事件的原理，只指定一个事件处理程序，就可以管理某一类型的所有事件。一般就是一次性将父元素绑定事件，通过判断event.target 来执行相应的方法，后续添加子元素的时候不用再次绑定

### passive为什么能优化页面的滚动性能
#### 单线程渲染框架，存在两个明显的问题：
- 流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理
- 内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件将无法立即得到响应

#### chrome的线程化渲染框架的两个线程
- 内核线程（Main/Render Thread）：负责DOM树构建、元素的布局、图层绘制记录部分（main-thread side）、JavaScript的执行
- 合成线程（Compositor Thread）：图层绘制实现部分（impl-side）、图层图像合成

#### 优化第1个问题
- Chrome浏览器对内核线程负责的工作进行拆分，通过多线程并发处理提高渲染效率减少丢帧，如内核线程仅负责DOM树构建、元素的布局、图层绘制记录部分（main-thread side）、JavaScript的执行
- 图层绘制实现部分（impl-side）、图层图像合成则是交给合成线程负责处理

#### 用户输入事件分类
- 在内核线程处理的事件
- 直接由合成线程处理的事件
- 在内核线程处理的事件：需要经过内核线程处理的输入事件要在内核线程执行逻辑，遇到内核线程在忙，无法立即响应；
- 不经过内核线程就能快速处理的输入事件为手势输入事件（滑动、捏合）；虽然手势事件可以不在内核线程处理，但是手势事件的产生还是离不开内核线程；

#### 页面卡顿的原因
- 浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身无法优化这种场景
- 如连续的mousewheel事件默认可以产生GestureScrollUpdate事件，但是如果监听器内部调用了preventDefault函数，那么这种情况下则不应该产生GestureScrollUpdate手势事件的

#### passive 的作用
当属性passive的值为true的时候，代表该监听器内部不会调用preventDefault函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器；在事件处理函数中，调用preventDefault是无效的

